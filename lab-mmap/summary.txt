mmap总结：
mmap实现的大致流程：
1.添加mmap和munmap系统调用，在mmap中，申请一个vma对象，用来存储对应的mmap的相关信息。这里vma里存储的长度是映射的
长度，可能要大于文件的真实大小，这是为了后续munmap处理方便。这里的offset是已经删除掉的映射长度，为了在已知va查找是哪个vma
结构体时方便，这里可以不用offset，直接在munmap里改vma->start的位置，和映射总长度vma->length，如果从开始解除映射，就改
vma->strat，如果从中间解除映射到末尾就改vma->length。还有一个sruct file*File指针，这里不适用文件描述符是与linux实现
相对应，在用户open之后进行mmap、然后获得一个描述符fd，然后munmap，close，那么这个文件描述符fd就被释放掉了，我的映射
要通过struct file*访问对应的文件，而不是fd。在munmap系统调用里,首先找到对应的vma，调用walk函数，判断对应的pte是否是
有效的，如果有效就要根据对应的权限标志写入文件信息，解除映射。如果失效，就什么都不做。这里注意如果vma->length是0，要回收
vma空间，调用函数降低vma->ref。
2.在usertrap处理逻辑里加上s_cause()==0xd和0xf的情况，分别对应page load fault和page store fault，我猜测真实的
文件系统里这里要判断是否是vma访问错误。这两种错误对应的处理逻辑是一样的，先找到对应的vma结构体，然后检查权限，接着申请
物理内存，写入对应的文件数据，建立映射mmapges。
3.在fork系统调用中，要进行物理内存的copy，调用uvmcopy。在没有引入mmap的XV6系统里，当检查到pte是失效的时候，直接报错，
这里似乎在加载大文件时还可以利用内存池、直接I/O什么的方法。引入了Mmap后，遇到pte失效的情况，这是没有建立map的大文件，
应当直接跳过处理。另外，还要copy vmas数组，这里是在内核中拷贝，要增加对应的file->ref。
4.在exit系统调用中，要进行清理内核中的vmas数组，回收空间，要降低file引用计数，注意这里uvmunmap在处理pte失效的情况时
和uvmcopy一样，也要跳过。